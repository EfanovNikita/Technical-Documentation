<!DOCTYPE html>
<html>

<head>
    <title>Fourth task</title>
    <meta name="viewport" content="width=device-width">
    <link
        href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap"
        rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Slab&display=swap" rel="stylesheet">
    <link href="./style.css" rel="stylesheet">

</head>

<body>
    <div class="container">
        <nav id="navbar">
            <header>
                <h1>React hooks API</h1>
            </header>
            <a class="nav-link" href="#introduction">Введение в хуки</a>
            <a class="nav-link" href="#short-review">Краткий обзор хуков</a>
            <a class="nav-link" href="#useState">Использование хука состояния</a>
            <a class="nav-link" href="#useEffect">Использование хука эффекта</a>
            <a class="nav-link" href="#rules">Правила хуков</a>
            <a class="nav-link" href="#createHook">Создание пользовательских хуков</a>
            <a class="nav-link" href="#manual">Справочник API хуков</a>
        </nav>
        <main id="main-doc">
            <section class="main-section" id="introduction">
                <header id="Введение_в_хуки">
                    <h1>Введение в хуки</h1>
                </header>
                <p>Хуки — нововведение в React 16.8, которое позволяет использовать состояние и другие возможности React
                    без написания классов.</p>
                <code>
                    <pre>
import React, { useState } from 'react';

function Example() {
    // Объявление переменной состояния, которую мы назовём "count"
    const [count, setCount] = useState(0);

    return (
        &lt;div&gt;
            &lt;p&gt;Вы кликнули {count} раз&lt;/p&gt;
            &lt;button onClick={() => setCount(count + 1)}&gt; Нажми на меня &lt;/button&gt;
        &lt;/div&gt;
    );
}
                    </pre>
                </code>
                <p>Перед тем, как мы продолжим, обратите внимание, что хуки:</p>
                <ul>
                    <li><strong>Полностью на ваше усмотрение.</strong> Вы можете попробовать хуки в одних компонентах,
                        не изменяя код в
                        других. Хуки не обязательно использовать или изучать прямо сейчас.</li>
                    <li><strong>100% обратно совместимы.</strong> Хуки не содержат изменений, которые могут поломать ваш
                        существующий код.</li>
                    <li><strong>Доступны прямо сейчас.</strong> Хуки доступны с выходом версии 16.8.0.</li>
                </ul>
                <p>
                    <strong>Хуки не меняют ваши знания о концепциях в React.</strong> Вместо этого, хуки предоставляют
                    более прямой доступ
                    к API уже знакомых вам понятий: пропсов, состояния, контекста, рефов, и жизненного цикла. Мы также
                    рассмотрим мощный способ компоновать эти понятия с помощью хуков.
                </p>
                <h2>Мотивация</h2>
                <p>
                    Хуки решают множество, казалось бы, несвязанных между собой, проблем в React, с которыми мы
                    сталкивались в течение пяти лет написания и поддержки десятков тысяч компонентов. Если вы изучаете
                    React, используете его ежедневно или используете другую библиотеку с похожим компонентным подходом,
                    эти проблемы наверняка покажутся вам знакомыми.
                </p>
                <h2>Трудно повторно использовать логику состояний между компонентами</h2>
                <p>
                    В React нет способа «присоединить» повторно используемое поведение к компоненту (например,
                    подключение к хранилищу). Если вы работали с React какое-то время, то вам могут быть знакомы такие
                    паттерны, как рендер-пропсы и компоненты высшего порядка, которые пытаются решить эту проблему. Но
                    эти паттерны заставляют вас изменять структуру компонентов, что делает код громоздким и трудным в
                    поддержке. Если вы посмотрите на типичное React-приложение в React DevTools, то увидите «ад обёрток»
                    из компонентов, окружённых провайдерами, консьюмерами, компонентами высшего порядка, рендер-пропсами
                    и другими абстракциями. Хоть мы и можем отфильтровать их в DevTools, всё это указывает на более
                    глубокую проблему в React. Нужен более удобный способ повторно использовать логику вокруг состояния.
                </p>
                <p>
                    С помощью хуков вы можете извлечь логику состояния из компонента, чтобы её протестировать или
                    повторно использовать. Хуки позволяют вам повторно использовать логику состояния, не затрагивая
                    дерево компонентов. Благодаря этому, хуки легко использовать в разных компонентах и делиться ими с
                    сообществом.
                </p>
                <p>Мы обсудим это подробнее в разделе Создание собственных хуков.</p>
                <h2>Сложные компоненты становятся трудными для понимания</h2>
                <p>
                    Нам часто приходилось поддерживать компоненты, которые изначально были простыми, но превратились в
                    неуправляемый беспорядок, состоящий из логики состояния и побочных эффектов. Каждый метод жизненного
                    цикла часто содержит смесь несвязанной логики. Например, компоненты могут загружать данные в
                    componentDidMount и componentDidUpdate. Однако тот же метод componentDidMount может содержать
                    несвязанную логику, которая добавляет обработчики события с отменой подписки в componentWillUnmount.
                    Взаимосвязанный код, который изменяется вместе, разделяется, но совершенно несвязанный код в
                    конечном итоге объединяется в один метод. Это легко приводит к багам и несоответствиям в приложении.
                </p>
                <p>
                    В некоторых случаях невозможно разбить компоненты на более мелкие, потому что логика состояния
                    раскидана повсюду. Такие компоненты сложно тестировать. Это одна из причин, по которой люди
                    предпочитают использовать в React отдельную библиотеку для управления состоянием. Однако, это
                    добавляет множество абстракций, заставляет прыгать между разными файлами и усложняет повторное
                    использование компонентов.
                </p>
                <p>
                    Чтобы решить эту проблему, хуки позволяют разбить один компонент на маленькие функции по их
                    назначению (например, подписке или загрузке данных), а не на основе методов жизненного цикла. Вы
                    также можете контролировать внутреннее состояние с помощью редюсера, чтобы поведение было более
                    предсказуемым.
                </p>
                <p>
                    Мы обсудим это в разделе использование эффект-хуков.
                </p>
                <h2>Классы путают как людей, так и машины</h2>
                <p>
                    Вдобавок к усложнению организации кода и его повторного использования, классы создают существенный
                    барьер в изучении React. Нужно понимать, как работает this в JavaScript, поведение которого
                    отличается от большинства языков. Приходится помнить про привязку контекста для обработчиков
                    событий. Без использования нестабильных синтаксических предложений, код становится многословным.
                    Люди могут прекрасно понимать пропсы, состояние и однонаправленный поток данных, но всё равно
                    путаться с классами. Различия между функциональными и классовыми компонентами в React и тем, когда
                    их использовать, приводят к разногласиям даже между опытными React-разработчиками.
                </p>
                <p>
                    Вдобавок, React существует уже около пяти лет и мы хотим убедиться, что он останется актуальным в
                    течение следующих пяти лет. Как показывают Svelte, Angular, Glimmer и другие технологии, компиляция
                    компонентов перед их исполнением имеет огромный потенциал в будущем. Особенно, если шаблоны не
                    накладывают ограничений. Недавно мы экспериментировали со свёртыванием компонентов с использованием
                    Prepack и увидели первые многообещающие результаты. Однако мы заметили, что классовые компоненты
                    могут приводить к ненамеренным паттернам, сводящим оптимизации на нет. Классы создают сложности для
                    инструментов и сегодня. Например, классы плохо минифицируются, а горячая перезагрузка (hot
                    reloading) ненадёжна и часто ломает их. Наша цель — предоставить API, который повысит вероятность
                    того, что код можно будет оптимизировать.
                </p>
                <p>
                    Чтобы решить эти проблемы, хуки позволяют использовать больше возможностей React без написания
                    классов. Концептуально, React-компоненты всегда были ближе к функциям. Хуки обеспечивают доступ к
                    функционалу, но не обесценивают опыт использования React. Хуки предоставляют императивные лазейки и
                    не требуют от вас изучения сложных функциональных или реактивных подходов.
                </p>
            </section>
            <section class="main-section" id="short-review">
                <header id="Краткий_обзор_хуков">
                    <h1>Краткий обзор хуков</h1>
                </header>
                <h2>Хук состояния</h2>
                <p>
                    Рассмотрим пример, в котором рендерится счётчик. Если вы нажмёте на кнопку, значение счётчика будет
                    инкрементировано.
                </p>
                <code>
                    <pre>
import React, { useState } from 'react';

function Example() {
    // Объявляем новую переменную состояния "count"
    const [count, setCount] = useState(0);
                        
    return (
        &lt;div&gt;
            &lt;p&gt;Вы нажали {count} раз&lt;/p&gt;
            &lt;button onClick={() => setCount(count + 1)}&gt;
                Нажми на меня
            &lt;/button&gt;
        &lt;/div&gt;
    );
}
                    </pre>
                </code>
                <p>
                    В этом примере, <strong>useState</strong> — это хук (определение хука дано ниже). Мы вызываем его,
                    чтобы наделить наш
                    функциональный компонент внутренним состоянием. React будет хранить это состояние между рендерами.
                    Вызов <strong>useState</strong> возвращает две вещи: текущее значение состояния и функцию для его
                    обновления. Эту
                    функцию можно использовать где угодно, например, в обработчике событий. Она схожа с this.setState в
                    классах, но не сливает новое и старое состояние вместе. Сравнение хука useState и this.state
                    приводится на странице Использование хука состояния.
                </p>
                <p>
                    Единственный аргумент <strong>useState</strong> — это начальное состояние. В примере выше — это 0,
                    так как наш
                    счётчик начинается с нуля. Заметьте, что в отличие от this.state, в нашем случае состояние может, но
                    не обязано, быть объектом. Исходное значение аргумента используется только при первом рендере.
                </p>
                <h3>Объявление нескольких переменных состояния</h3>
                <p>
                    Хук состояния можно использовать в компоненте более одного раза.
                </p>
                <code>
<pre>
function ExampleWithManyStates() {
    // Объявляем несколько переменных состояния!
    const [age, setAge] = useState(42);
    const [fruit, setFruit] = useState('банан');
    const [todos, setTodos] = useState([{ text: 'Изучить хуки' }]);
    // ...
}
</pre>
                </code>
                <p>
                    Синтаксис деструктуризации массивов позволяет нам по-разному называть переменные состояния, которые
                    мы объявляем при вызове useState. Так как имён этих переменных нет в API useState, React
                    предполагает, что если вы вызываете useState много раз, вы делаете это в одинаковой
                    последовательности при каждом рендере. Мы расскажем, почему это работает и когда это целесообразно,
                    немного позже.
                </p>
                <h3>Что же такое хук?</h3>
                <p>
                    Хуки — это функции, с помощью которых вы можете «подцепиться» к состоянию и методам жизненного цикла
                    React из функциональных компонентов. Хуки не работают внутри классов — они дают вам возможность
                    использовать React без классов.
                </p>
                <p>
                    React содержит несколько встроенных хуков, таких как <strong>useState</strong>. Вы также можете
                    создавать собственные
                    хуки, чтобы повторно использовать их в других своих компонентах. Давайте для начала рассмотрим
                    встроенные хуки.
                </p>
                <h2>Хук эффекта</h2>
                <p>
                    Вам скорее всего доводилось ранее запрашивать данные, делать подписки или вручную менять DOM из
                    React-компонента. Мы расцениваем эти операции как «побочные эффекты» (или сокращённо «эффекты»), так
                    как они могут влиять на работу других компонентов и их нельзя выполнить во время рендера.
                </p>
                <p>
                    С помощью хука эффекта useEffect вы можете выполнять побочные эффекты из функционального компонента.
                    Он выполняет ту же роль, что и componentDidMount, componentDidUpdate и componentWillUnmount в
                    React-классах, объединив их в единый API. Вы можете найти сравнение useEffect и этих методов на
                    странице использование хука эффекта.
                </p>
                <p>
                    К примеру, этот компонент устанавливает заголовок документа после того, как React обновляет DOM:
                </p>
                <code>
<pre>
import React, { useState, useEffect } from 'react';

function Example() {
    const [count, setCount] = useState(0);
    
    // По принципу componentDidMount и componentDidUpdate:
    useEffect(() => {
        // Обновляем заголовок документа, используя API браузера
        document.title = `Вы нажали ${count} раз`;
    });
    
    return (
        &lt;div&gt;
        &lt;p&gt;Вы нажали {count} раз&lt;/p&gt;
            &lt;button onClick={() => setCount(count + 1)}&gt;
                Нажми на меня
            &lt;/button&gt;
        &lt;/div&gt;
    );
}
</pre>
                </code>
                <p>
                    Когда вы вызываете useEffect, React получает указание запустить вашу функцию с «эффектом» после
                    того, как он отправил изменения в DOM. Поскольку эффекты объявляются внутри компонента, у них есть
                    доступ к его пропсам и состоянию. По умолчанию, React запускает эффекты после каждого рендера,
                    включая первый рендер. Мы рассмотрим более подробно, как это отличается от классовых методов
                    жизненного цикла на странице использование хука эффекта.
                </p>
                <p>
                    При необходимости вы можете вернуть из эффекта функцию, которая указывает эффекту, как выполнить за
                    собой «сброс». Например, этот компонент использует эффект, чтобы подписаться на статус друга в сети,
                    и выполняет сброс, отписываясь от него.
                </p>
                <code>
<pre>
import React, { useState, useEffect } from 'react';

function FriendStatus(props) {
  const [isOnline, setIsOnline] = useState(null);

  function handleStatusChange(status) {
    setIsOnline(status.isOnline);
  }

  useEffect(() => {
    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
    return () => {
      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
    };
  });

  if (isOnline === null) {
    return 'Загрузка...';
  }
  return isOnline ? 'В сети' : 'Не в сети';
}
</pre>
                </code>
                <p>
                    В этом примере, React будет отписываться от нашего ChatAPI перед тем, как компонент размонтируется и
                    перед тем, как перезапустить эффект при повторном рендере. Вы можете сделать так, чтобы React
                    пропускал повторные подписки если props.friend.id, который мы передали в ChatAPI, остался без
                    изменений.
                </p>
                <p>
                    Так же как и useState, вы можете использовать более одного эффекта в компоненте:
                </p>
                <code>
<pre>
function FriendStatusWithCounter(props) {
  const [count, setCount] = useState(0);
  useEffect(() => {
    document.title = `Вы нажали ${count} раз`;
  });

  const [isOnline, setIsOnline] = useState(null);
  useEffect(() => {
    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
    return () => {
      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
    };
  });

  function handleStatusChange(status) {
    setIsOnline(status.isOnline);
  }
  // ...
</pre>
                </code>
                <p>
                    Хуки дают вам возможность организовать побочные эффекты в компоненте по связанным частям (например,
                    добавление или отмена подписки), вместо того, чтобы принуждать вас делить всё согласно методам
                    жизненного цикла.
                </p>
                <h2>Создание собственных хуков</h2>
                <p>
                    Иногда нужно повторно использовать одинаковую логику состояния в нескольких компонентах. Традиционно
                    использовались два подхода: компоненты высшего порядка и рендер-пропсы. С помощью пользовательских
                    хуков эта задача решается без добавления ненужных компонентов в ваше дерево.
                </p>
                <p>
                    Ранее на этой странице мы рассматривали компонент FriendStatus, который вызывал хуки useState и
                    useEffect, чтобы подписаться на статус друга в сети. Допустим, мы хотим ещё раз использовать эту
                    логику с подпиской, но уже в другом компоненте.
                </p>
                <p>
                    Прежде всего, давайте извлечём эту логику в пользовательский хук useFriendStatus
                </p>
                <code>
<pre>
import React, { useState, useEffect } from 'react';

function useFriendStatus(friendID) {
  const [isOnline, setIsOnline] = useState(null);

  function handleStatusChange(status) {
    setIsOnline(status.isOnline);
  }

  useEffect(() => {
    ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange);
    return () => {
      ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange);
    };
  });

  return isOnline;
}
</pre>
                </code>
                <p>
                    Хук принимает friendID в качестве аргумента и возвращает переменную, которая показывает, в сети наш
                    друг или нет.
                </p>
                <p>
                    Теперь мы можем использовать этот хук в обоих наших компонентах:
                </p>
                <code>
<pre>
function FriendStatus(props) {
  const isOnline = useFriendStatus(props.friend.id);

  if (isOnline === null) {
    return 'Загрузка...';
  }
  return isOnline ? 'В сети' : 'Не в сети';
}
</pre>
                </code>
                <code>
<pre>
function FriendListItem(props) {
  const isOnline = useFriendStatus(props.friend.id);

  return (
    &lt;li style={{ color: isOnline ? 'green' : 'black' }}&gt;
      {props.friend.name}
      &lt;/li&gt;
  );
}
</pre>
                </code>
                <p>
                    Состояния каждого компонента никаким образом не зависят друг от друга. Хуки — это способ
                    использовать повторно логику состояния, а не само состояние. Более того, каждое обращение к хуку
                    обеспечивает совершенно изолированное состояние. Вы даже можете использовать один и тот же хук
                    несколько раз в одном компоненте.
                </p>
                <p>
                    Пользовательские хуки — это в большей степени соглашение, чем дополнение. Если имя функции
                    начинается с ”use” и она вызывает другие хуки, мы расцениваем это как пользовательский хук. Если вы
                    будете придерживаться соглашения useSomething при именовании хуков, это позволит нашему плагину для
                    линтера найти баги в коде, который использует хуки.
                </p>
                <h2>Другие хуки</h2>
                <p>
                    Есть ещё несколько менее используемых встроенных хуков, которые могут вам пригодиться. Например, с
                    помощью useContext, вы можете подписаться на контекст React без использования каких-либо вложений.
                </p>
                <code>
<pre>
function Example() {
  const locale = useContext(LocaleContext);
  const theme = useContext(ThemeContext);
  // ...
}
</pre>
                </code>
                <p>
                    А хук useReducer даёт возможность управлять внутренним состоянием более сложного компонента с
                    помощью редюсера.
                </p>
                <code>
<pre>
function Todos() {
  const [todos, dispatch] = useReducer(todosReducer);
  // ...
</pre>
                </code>
                <p>
                    Вы можете узнать больше обо всех встроенных хуках на странице API-справочника хуков.
                </p>
            </section>
            <section class="main-section" id="useState">
                <header id="Использование_хука_состояния">
                    <h1>Использование хука состояния</h1>
                </header>
                <p>
                    На странице введения в хуки мы познакомились с ними на этом примере:
                </p>
                <code>
<pre>
import React, { useState } from 'react';

function Example() {
  // Объявление новой переменной состояния «count»
  const [count, setCount] = useState(0);

  return (
    &lt;div&gt;
    &lt;p>Вы кликнули {count} раз(а)&lt;/p&gt;
        &lt;button onClick={() => setCount(count + 1)}&gt;
            Нажми на меня
        &lt;/button&gt;
    &lt;/div&gt;
  );
}
</pre>
                </code>
                <p>
                    Давайте начнём изучать хуки, сравнив этот код с эквивалентным кодом на основе класса.
                </p>
                <h2>Эквивалентный пример с классом</h2>
                <p>
                    Если вы уже пользовались классами в React, то вам знаком такой код:
                </p>
                <code>
<pre>
class Example extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      count: 0
    };
  }

  render() {
    return (
        &lt;div&gt;
            &lt;p>Вы кликнули {this.state.count} раз(а)&lt;/p&gt;
            &lt;button onClick={() => this.setState({ count: this.state.count + 1 })}&gt;
                Нажми на меня
            &lt;/button&gt;
        &lt;/div&gt;
    );
  }
}
</pre>
                </code>
                <p>
                    Сначала состояние выглядит как { count: 0 }. Каждый раз, когда пользователь кликает, мы увеличиваем
                    state.count на единицу, вызывая this.setState(). Мы будем использовать фрагменты этого класса на
                    протяжении всей страницы.
                </p>
                <h2>Что такое хук?</h2>
                <p>
                    Наш новый пример начинается с того, что импортирует хук useState из React:
                </p>
                <code>
<pre>
import React, { useState } from 'react';

function Example() {
  // ...
}
</pre>
                </code>
                <p>
                    <strong>Что такое хук?</strong> Хук — это специальная функция, которая позволяет «подцепиться» к
                    возможностям React.
                    Например, хук useState предоставляет функциональным компонентам доступ к состоянию React. Мы узнаем
                    про другие хуки чуть позже.
                </p>
                <p>
                    <strong>Когда применить хук?</strong> Раньше, если вы писали функциональный компонент и осознавали,
                    что вам нужно
                    наделить его состоянием, вам приходилось превращать этот компонент в класс. Теперь же вы можете
                    использовать хук внутри существующего функционального компонента. Мы покажем это прямо сейчас!
                </p>
                <h2>Объявление переменной состояния</h2>
                <p>
                    Допустим, мы хотим инициализировать в классе состояние count значением 0. Для этого в его
                    конструкторе присваиваем this.state объект { count: 0 }:
                </p>
                <code>
<pre>
class Example extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      count: 0
    };
  }
</pre>
                </code>
                <p>
                    В функциональном компоненте нам недоступен this, поэтому мы не можем задать или считать состояние
                    через this.state. Вместо этого мы вызываем хук useState напрямую изнутри нашего компонента.
                </p>
                <code>
<pre>
import React, { useState } from 'react';

function Example() {
  // Объявление новой переменной состояния «count»
  const [count, setCount] = useState(0)
</pre>
                </code>
                <p>
                    <strong>Что делает вызов useState?</strong> Он объявляет «переменную состояния». Мы называли
                    переменную count, но
                    могли дать ей любое имя, хоть банан. Таким образом мы можем «сохранить» некоторые значения между
                    вызовами функции. useState это новый способ использовать те же возможности, что даёт this.state в
                    классах. Обычно переменные «исчезают» при выходе из функции. К переменным состояния это не
                    относится, потому что их сохраняет React.
                </p>
                <p>
                    <strong>Какие аргументы передавать useState?</strong> Единственный аргумент useState это исходное
                    состояние. В
                    отличие от случая с классами, состояние может быть и не объектом, а строкой или числом, если нам так
                    удобно. Поскольку в нашем примере отслеживается количество сделанных пользователем кликов, мы
                    передаём 0 в качестве исходного значения переменной. (Если нам нужно было бы хранить два разных
                    значения в состоянии, то пришлось бы вызвать useState() дважды.)
                </p>
                <p>
                    <strong>Что возвращается из useState?</strong> Вызов useState вернёт пару значений: текущее
                    состояние и функцию,
                    обновляющую состояние. Поэтому мы пишем const [count, setCount] = useState(). Это похоже на
                    this.state.count и this.setState в классах, с той лишь разницей, что сейчас мы принимаем их сразу в
                    паре. Если вам незнаком использованный синтаксис, мы вернёмся к нему ближе к концу страницы.
                </p>
                <p>
                    Теперь мы знаем, что делает useState, и пример должен быть ясен:
                </p>
                <code>
<pre>
import React, { useState } from 'react';

function Example() {
  // Объявление новой переменной состояния «count»
  const [count, setCount] = useState(0);
</pre>
                </code>
                <p>
                    Мы объявляем переменную состояния count и устанавливаем ей значение 0. React будет помнить текущее
                    (наиболее свежее) значение между рендерингами и передавать его нашей функции. Если мы захотим
                    изменить count, мы вызовем setCount.
                </p>
                <h2>Чтение состояния</h2>
                <p>
                    Когда мы хотим отобразить текущее состояние счётчика в классе, мы обращаемся к this.state.count:
                </p>
                <code>
<pre>
&lt;p&gt;Вы кликнули {this.state.count} раз(а)&lt;/p&gt;
</pre>
                </code>
                <p>
                    В функции же мы можем использовать count напрямую:
                </p>
                <code>
<pre>
&lt;p&gt;Вы кликнули {count} раз(а)&lt;/p&gt;
</pre>
                </code>
                <h2>Обновление состояния</h2>
                <p>
                    В классе мы вызываем this.setState(), когда надо обновить состояние count:
                </p>
                <code>
<pre>
&lt;button onClick={() => this.setState({ count: this.state.count + 1 })}&gt;
    Нажми на меня
&lt;/button&gt;
</pre>
                </code>
                <p>
                    В функции нам не нужен this, потому что setCount и count уже доступны как переменные:
                </p>
                <code>
<pre>
&lt;button onClick={() => setCount(count + 1)}&gt;
    Нажми на меня
&lt;/button&gt;
</pre>
                </code>
                <h2>Совет: Что делают квадратные скобки?</h2>
                <p>
                    Вы могли обратить внимание на квадратные скобки в месте, где объявляется переменная состояния:
                </p>
                <code>
<pre>
const [count, setCount] = useState(0);
</pre>
                </code>
                <p>
                    Два имени в квадратных скобках не содержатся в API React. Названия переменным состояния выбираете
                    вы:
                </p>
                <code>
<pre>
const [fruit, setFruit] = useState('банан');
</pre>
                </code>
                <p>
                    Такой синтаксис в JavaScript называется «деструктуризацией массивов (array destructuring)». Он
                    означает, что мы создаём две новые переменные, fruit и setFruit. Во fruit будет записано первое
                    значение, вернувшееся из useState, а в setFruit — второе, что равносильно такому коду:
                </p>
                <code>
<pre>
var fruitStateVariable = useState('банан'); // Возвращает пару значений
var fruit = fruitStateVariable[0]; // Извлекаем первое значение
var setFruit = fruitStateVariable[1]; // Извлекаем второе значение
</pre>
                </code>
                <p>
                    Когда мы объявляем переменную состояния с помощью функции useState, мы получаем от неё пару, то есть
                    массив из двух элементов. Первый элемент обозначает текущее значение, а второй является функцией,
                    позволяющей менять это значение. Доступ к элементам через [0] и [1] менее ясен, потому что индексы
                    лишены осмысленных имён.
                </p>
                <h2>Совет: Использование нескольких переменных состояния</h2>
                <p>
                    Объявлять переменные состояния через пару [something, setSomething] удобно ещё и тем, что когда нам
                    нужны несколько переменных, мы можем назвать каждую из них собственным именем:
                </p>
                <code>
<pre>
function ExampleWithManyStates() {
  // Объявим несколько переменных состояния!
  const [age, setAge] = useState(42);
  const [fruit, setFruit] = useState('банан');
  const [todos, setTodos] = useState([{ text: 'Изучить хуки' }]);
</pre>
                </code>
                <p>
                    В примере выше мы видим локальные переменные age, fruit и todos, которые можем обновлять независимо
                    друг от друга:
                </p>
                <code>
<pre>
function handleOrangeClick() {
    // Аналогично коду this.setState({ fruit: 'апельсин' })
    setFruit('апельсин');
}
</pre>
                </code>
                <p>
                    Использовать несколько переменных состояния совсем не обязательно, потому что они могут быть
                    объектами или массивами, которые группируют связанные по смыслу данные. Обратите внимание, что, в
                    отличие от this.setState в классах, обновление переменной состояния всегда замещает её значение, а
                    не осуществляет слияние.
                </p>
            </section>
            <section class="main-section" id="useEffect">
                <header id="Использование_хука_эффекта">
                    <h1>Использование хука эффекта</h1>
                </header>
                <p>
                    Хук эффекта даёт вам возможность выполнять побочные эффекты в функциональном компоненте:
                </p>
                <code>
<pre>
import React, { useState, useEffect } from 'react';

function Example() {
  const [count, setCount] = useState(0);

  // Аналогично componentDidMount и componentDidUpdate:
  useEffect(() => {
    // Обновляем заголовок документа с помощью API браузера
    document.title = `Вы нажали ${count} раз`;
  });

  return (
    &lt;div&gt;
        &lt;p&gt;Вы нажали {count} раз&lt;/p&gt;
        &lt;button onClick={() => setCount(count + 1)}&gt;
            Нажми на меня
        &lt;/button&gt;
    &lt;/div&gt;
  );
}
</pre>
                </code>
                <p>
                    Этот фрагмент основан на примере со счётчиком из предыдущей страницы, только мы добавили новую
                    функциональность: мы изменяем заголовок документа на пользовательское сообщение, которое также
                    содержит количество нажатий кнопки.
                </p>
                <p>
                    Побочными эффектами в React-компонентах могут быть: загрузка данных, оформление подписки и изменение
                    DOM вручную. Неважно, называете ли вы эти операции «побочными эффектам» (или просто «эффектами») или
                    нет, скорее всего вам доводилось ранее использовать их в своих компонентах.
                </p>
                <p>
                    Если вам знакомы классовые методы жизненного цикла React, хук useEffect представляет собой
                    совокупность методов componentDidMount, componentDidUpdate, и componentWillUnmount.
                </p>
                <p>
                    Существует два распространённых вида побочных эффектов в компонентах React: компоненты, которые
                    требуют и не требуют сброса. Давайте рассмотрим оба примера более детально.
                </p>
                <h2>Эффекты без сброса</h2>
                <p>
                    Иногда мы хотим выполнить дополнительный код после того, как React обновил DOM. Сетевые запросы,
                    изменения DOM вручную, логирование — всё это примеры эффектов, которые не требуют сброса. После
                    того, как мы запустили их, можно сразу забыть о них, ведь больше никаких дополнительных действий не
                    требуется. Давайте сравним, как классы и хуки позволяют нам реализовывать побочные эффекты.
                </p>
                <h3>Пример с использованием классов</h3>
                <p>
                    В классовых React-компонентах метод render сам по себе не должен вызывать никаких побочных эффектов.
                    Он не подходит для этих целей, так как в основном мы хотим выполнить наши эффекты после того, как
                    React обновил DOM.
                </p>
                <p>
                    Вот почему в классах React мы размещаем побочные эффекты внутрь componentDidMount и
                    componentDidUpdate. Возвращаясь к нашему примеру, здесь представлен счётчик, реализованный с помощью
                    классового React-компонента. Он обновляет заголовок документа сразу же после того, как React вносит
                    изменения в DOM:
                </p>
                <code>
<pre>
class Example extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      count: 0
    };
  }

  componentDidMount() {
    document.title = `Вы нажали ${this.state.count} раз`;
  }
  componentDidUpdate() {
    document.title = `Вы нажали ${this.state.count} раз`;
  }

  render() {
    return (
      &lt;div&gt;
        &lt;p>Вы нажали {this.state.count} раз&lt;/p&gt;
        &lt;button onClick={() => this.setState({ count: this.state.count + 1 })}&gt;
          Нажми на меня
        &lt;/button&gt;
      &lt;/div&gt;
    );
  }
}
</pre>
                </code>
                <p>
                    Обратите внимание, что <strong>нам приходится дублировать наш код между этими классовыми методами
                        жизненного
                        цикла.</strong>
                </p>
                <p>
                    Это всё потому, что во многих случаях, мы хотим выполнять одни и те же побочные эффекты вне
                    зависимости от того, был ли компонент только что смонтирован или обновлён. Мы хотим чтобы они
                    выполнялись после каждого рендера — но у классовых React-компонентов нет таких встроенных методов.
                    Мы могли бы вынести этот метод отдельно, но нам бы всё равно пришлось бы вызывать его в двух местах.
                </p>
                <p>
                    А сейчас, давайте рассмотрим, как мы можем сделать то же самое с использованием хука useEffect.
                </p>
                <h3>Пример с использованием хуков</h3>
                <p>
                    Мы уже рассматривали этот пример немного ранее, но давайте разберём его более подробно:
                </p>
                <code>
<pre>
import React, { useState, useEffect } from 'react';

function Example() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    document.title = `Вы нажали ${count} раз`;
  });

  return (
    &lt;div&gt;
      &lt;p>Вы нажали {count} раз&lt;/p&gt;
      &lt;button onClick={() => setCount(count + 1)}&gt;
        Нажми на меня
      &lt;/button&gt;
    &lt;/div&gt;
  );
}
</pre>
                </code>
                <p>
                    <strong>Что же делает useEffect?</strong> Используя этот хук, вы говорите React сделать что-то после
                    рендера. React
                    запомнит функцию (то есть «эффект»), которую вы передали и вызовет её после того, как внесёт все
                    изменения в DOM. В этом эффекте мы устанавливаем заголовок документа, но мы также можем выполнить
                    запрос данных или вызвать какой-нибудь императивный API.
                </p>
                <p>
                    <strong>Почему же мы вызываем useEffect непосредственно внутри компонента?</strong> Это даёт нам
                    доступ к переменной
                    состояния count (или любым другим пропсам) прямиком из эффекта. Нам не нужен специальный API для
                    доступа к этой переменной — она уже находится у нас в области видимости функции. Хуки используют
                    JavaScript-замыкания, и таким образом, им не нужен специальный API для React, поскольку сам
                    JavaScript уже имеет готовое решение для этой задачи.
                </p>
                <p>
                    <strong>Выполняется ли useEffect после каждого рендера?</strong> Разумеется! По умолчанию он будет
                    выполняться после
                    каждого рендера и обновления. Мы рассмотрим, как настраивать это немного позже. Вместо того, чтобы
                    воспринимать это с позиции «монтирования» и «обновления», мы советуем просто иметь в виду, что
                    эффекты выполняются после каждого рендера. React гарантирует, что он запустит эффект только после
                    того, как DOM уже обновился.
                </p>
                <h3>Подробное объяснение</h3>
                <p>
                    Мы узнали немного больше о принципе работы эффектов и теперь этот код уже вовсе не кажется таким
                    непонятным:
                </p>
                <code>
<pre>
function Example() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    document.title = `Вы нажали ${count} раз`;
  });
}
</pre>
                </code>
                <p>
                    Мы объявляем переменную состояния count и говорим React, что мы хотим использовать эффект. Далее, мы
                    передаём функцию в хук useEffect. Эта функция как раз и будет нашим эффектом. Внутри этого эффекта
                    мы устанавливаем заголовок документа, используя API браузера document.title. Мы можем получать
                    доступ к актуальной переменной count изнутри эффекта, так как он находится в области видимости нашей
                    функции. Когда React рендерит наш компонент, он запоминает эффект, который мы использовали, и
                    запускает его после того, как обновит DOM. Это будет происходить при каждом рендере, в том числе и
                    при первоначальном.
                </p>
                <p>
                    Опытные JavaScript-разработчики могут подметить, что функция, которую мы передаём в useEffect, будет
                    меняться при каждом рендере. На самом деле, это было сделано преднамеренно. Это как раз то, что даёт
                    нам возможность получать актуальную версию переменной count изнутри эффекта, не беспокоясь о том,
                    что её значение устареет. Каждый раз при повторном рендере, мы ставим в очередь новый эффект,
                    который заменяет предыдущий. В каком-то смысле, это включает поведение эффектов как часть результата
                    рендера, то есть каждый эффект «принадлежит» определённому рендеру. Мы расскажем о преимуществах
                    данного подхода далее на этой странице.
                </p>
                <h2>Эффекты со сбросом</h2>
                <p>
                    Ранее мы рассмотрели побочные эффекты, которые не требуют сброса. Однако, есть случаи, когда сброс
                    всё же необходим. Например, нам может потребоваться установить подписку на какой-нибудь внешний
                    источник данных. В этом случае очень важно выполнять сброс, чтобы не случилось утечек памяти!
                    Давайте сравним, как мы можем это реализовать с помощью классов и хуков.
                </p>
                <h3>Пример с использованием классов</h3>
                <p>
                    В React-классе, вы, как правило, оформили бы подписку в componentDidMount и отменили бы её в
                    componentWillUnmount. Например, предположим, что у нас есть некий модуль ChatAPI, с помощью которого
                    мы можем подписаться на статус друга в сети. Вот как мы бы подписались и отобразили бы статус,
                    используя класс:
                </p>
                <code>
<pre>
class FriendStatus extends React.Component {
  constructor(props) {
    super(props);
    this.state = { isOnline: null };
    this.handleStatusChange = this.handleStatusChange.bind(this);
  }

  componentDidMount() {
    ChatAPI.subscribeToFriendStatus(
      this.props.friend.id,
      this.handleStatusChange
    );
  }
  componentWillUnmount() {
    ChatAPI.unsubscribeFromFriendStatus(
      this.props.friend.id,
      this.handleStatusChange
    );
  }
  handleStatusChange(status) {
    this.setState({
      isOnline: status.isOnline
    });
  }

  render() {
    if (this.state.isOnline === null) {
      return 'Загрузка...';
    }
    return this.state.isOnline ? 'В сети' : 'Не в сети';
  }
}
</pre>
                </code>
                <p>
                    Обратите внимание, что componentDidMount и componentWillUnmount по сути содержат идентичный код.
                    Методы жизненного цикла вынуждают нас разбивать эту логику, хоть и фактически код обоих методов
                    относится к одному и тому же эффекту.
                </p>
                <h3>Пример с использованием хуков</h3>
                <p>
                    Давайте рассмотрим, как этот компонент будет выглядеть, если написать его с помощью хуков.
                </p>
                <p>
                    Вы должно быть подумали, что нам потребуется отдельный эффект для выполнения сброса. Так как код для
                    оформления и отмены подписки тесно связан с useEffect, мы решили объединить их. Если ваш эффект
                    возвращает функцию, React выполнит её только тогда, когда наступит время сбросить эффект.
                </p>
                <code>
<pre>
import React, { useState, useEffect } from 'react';

function FriendStatus(props) {
  const [isOnline, setIsOnline] = useState(null);

  useEffect(() => {
    function handleStatusChange(status) {
      setIsOnline(status.isOnline);
    }
    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
    // Указываем, как сбросить этот эффект:
    return function cleanup() {
      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
    };
  });

  if (isOnline === null) {
    return 'Загрузка...';
  }
  return isOnline ? 'В сети' : 'Не в сети';
}
</pre>
                </code>
                <p>
                    <strong>Зачем мы вернули функцию из нашего эффекта?</strong> Это необязательный механизм сброса
                    эффектов. Каждый
                    эффект может возвратить функцию, которая сбросит его. Это даёт нам возможность объединить вместе
                    логику оформления и отмены подписки. Они, всё-таки, часть одного и того же эффекта!
                </p>
                <p>
                    <strong>Когда именно React будет сбрасывать эффект?</strong> React будет сбрасывать эффект перед
                    тем, как компонент размонтируется. Однако, как мы уже знаем, эффекты выполняются не один раз, а при
                    каждом рендере. Вот
                    почему React также сбрасывает эффект из предыдущего рендера, перед тем, как запустить следующий.
                </p>
                <p>
                    Нам не нужно возвращать именованную функцию из эффекта. Мы назвали её «сбросом», чтобы объяснить её
                    предназначение. Вы можете по желанию возвратить стрелочную функцию или назвать её как-то по-другому.
                </p>
            </section>
            <section class="main-section" id="rules">
                <header id="Правила_хуков">
                    <h1>Правила хуков</h1>
                </header>
                <h2>Используйте хуки только на верхнем уровне</h2>
                <p>
                    <strong>Не используйте хуки внутри циклов, условных операторов или вложенных функций.</strong>
                    Вместо этого всегда
                    используйте хуки только на верхнем уровне React-функций. Исполнение этого правила гарантирует, что
                    хуки вызываются в одинаковой последовательности при каждом рендере компонента. Это позволит React
                    правильно сохранять состояние хуков между множественными вызовами useState и useEffect.
                </p>
                <h2>Вызывайте хуки только из React-функций</h2>
                <p>
                    <strong>Не вызывайте хуки из обычных функций JavaScript.</strong> Вместо этого можно:
                <ul>
                    <li>Вызывать хуки из функционального компонента React.</li>
                    <li>Вызывать хуки из пользовательского хука.</li>
                </ul>
                </p>
                <p>
                    Как мы ранее узнали, хуки состояния или эффектов в одном и том же компоненте можно использовать
                    многократно:
                </p>
                <code>
<pre>
function Form() {
  // 1. Используем переменную состояния name
  const [name, setName] = useState('Мэри');

  // 2. Используем эффект для сохранения данных формы
  useEffect(function persistForm() {
    localStorage.setItem('formData', name);
  });

  // 3. Используем переменную состояния surname
  const [surname, setSurname] = useState('Поппинс');

  // 4. Используем эффект для обновления заголовка страницы
  useEffect(function updateTitle() {
    document.title = name + ' ' + surname;
  });

  // ...
}
</pre>
                </code>
                <p>
                    Итак, как же React сопоставляет переменные состояния с вызовами useState? Ответ таков: <strong>React
                        полагается на порядок вызова хуков.</strong> Наш пример работает, потому что порядок вызова
                    хуков одинаков
                    при каждом рендере.
                </p>
                <code>
<pre>
// ------------
// Первый рендер
// ------------
useState('Мэри')           // 1. Инициализируем переменную name значением 'Мэри'
useEffect(persistForm)     // 2. Добавляем эффект для сохранения данных формы
useState('Поппинс')        // 3. Инициализируем переменную surname значением 'Поппинс'
useEffect(updateTitle)     // 4. Добавляем эффект для обновления заголовка страницы

// -------------
// Второй рендер
// -------------
useState('Мэри')           // 1. Читаем переменную состояния name (аргумент игнорируется)
useEffect(persistForm)     // 2. Заменяем эффект сохранения данных формы
useState('Поппинс')        // 3. Читаем переменную состояния surname (аргумент игнорируется)
useEffect(updateTitle)     // 4. Заменяем эффект обновления заголовка страницы

// ...
</pre>
                </code>
                <p>
                    До тех пор пока порядок вызова хуков одинаков в каждом рендере, React может сопоставить некое
                    внутреннее состояние с каждым из них. Но что случится, если мы поместим вызов хука (например, эффект
                    persistForm) внутрь условного оператора?
                </p>
                <code>
<pre>
// 🔴 Нарушаем первое правило, помещая хук в условие
  if (name !== '') {
    useEffect(function persistForm() {
      localStorage.setItem('formData', name);
    });
  }
</pre>
                </code>
                <p>
                    Условие name !== '' равняется true при первом рендере, поэтому хук выполняется. Тем не менее, при
                    следующем рендере пользователь может обратить это условие в false, очистив поля формы. Теперь во
                    время рендера хук будет пропущен и порядок вызовов хуков изменится.
                </p>
                <code>
<pre>
useState('Мэри')           // 1. Читаем переменную состояния name (аргумент игнорируется)
// useEffect(persistForm)  // 🔴 Хук пропускается!
useState('Поппинс')        // 🔴 2 (но ранее был 3). Ошибка при чтении переменной состояния surname
useEffect(updateTitle)     // 🔴 3 (но ранее был 4). Ошибка при замене эффекта
</pre>
                </code>
                <p>
                    React не будет знать, что вернуть для второго вызова хука useState. React ожидал, что второй вызов
                    хука в этом компоненте соответствует эффекту persistForm, так же как при предыдущем рендере, но это
                    больше не так. Начиная с этого момента, вызов каждого хука, следующего за пропущенным, также будет
                    сдвинут на один назад, что приведёт к ошибкам.
                </p>
                <p>
                    <strong>Вот почему хуки должны вызываться на верхнем уровне компонента.</strong> Если мы хотим
                    запускать эффект по
                    условию, то можем поместить это условие внутрь хука:
                </p>
                <code>
<pre>
useEffect(function persistForm() {
    // 👍 Первое правило больше не нарушается
    if (name !== '') {
      localStorage.setItem('formData', name);
    }
  });
</pre>
                </code>
                <p>
                    Теперь вы знаете, почему хуки работают таким образом и какие проблемы это правило предотвращает.
                </p>
            </section>
            <section class="main-section" id="createHook">
                <header id="Создание_пользовательских_хуков">
                    <h1>Создание пользовательских хуков</h1>
                </header>
                <p>
                    Создание пользовательских хуков позволяет вам перенести логику компонентов в функции, которые можно
                    повторно использовать.
                </p>
                <p>
                    В разделе использование хука эффекта мы увидели компонент из приложения чата, в котором отображается
                    сообщение о том, находится ли наш друг в сети:
                </p>
                <code>
<pre>
import React, { useState, useEffect } from 'react';

function FriendStatus(props) {
  const [isOnline, setIsOnline] = useState(null);
  useEffect(() => {
    function handleStatusChange(status) {
      setIsOnline(status.isOnline);
    }
    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
    return () => {
      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
    };
  });

  if (isOnline === null) {
    return 'Загрузка...';
  }
  return isOnline ? 'В сети' : 'Не в сети';
}
</pre>
                </code>
                <p>
                    Теперь предположим, что в приложении чата также есть список контактов, и мы хотим отображать зелёным
                    цветом имена пользователей, которые сейчас в сети. Мы могли бы просто скопировать и вставить
                    приведённую выше логику в наш компонент FriendListItem, но это не самый лучший вариант:
                </p>
                <code>
<pre>
import React, { useState, useEffect } from 'react';

function FriendListItem(props) {
  const [isOnline, setIsOnline] = useState(null);
  useEffect(() => {
    function handleStatusChange(status) {
      setIsOnline(status.isOnline);
    }
    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
    return () => {
      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
    };
  });

  return (
    &lt;li style={{ color: isOnline ? 'green' : 'black' }}&gt;
      {props.friend.name}
    &lt;/li&gt;
  );
}
</pre>
                </code>
                <p>
                    Вместо этого, мы бы хотели, чтобы FriendStatus и FriendListItem разделяли эту логику.
                </p>
                <p>
                    Когда одинаковую логику состояния нужно повторно использовать в нескольких компонентах, в React
                    традиционно применялись рендер-пропсы и компоненты высшего порядка. Рассмотрим, как хуки решают
                    многие из тех же задач, не добавляя лишних компонентов в ваше дерево.
                </p>
                <h2>Извлечение логики в пользовательский хук</h2>
                <p>
                    Когда мы хотим, чтобы две JavaScript-функции разделяли какую-то логику, мы извлекаем её в третью
                    функцию. И компоненты и хуки являются функциями, поэтому с ними это тоже работает!
                </p>
                <p>
                    <strong>Пользовательский хук — это JavaScript-функция, имя которой начинается с «use», и которая
                        может
                        вызывать другие хуки.</strong> Например, функция useFriendStatus ниже — это наш первый
                    пользовательский хук:
                </p>
                <code>
<pre>
import { useState, useEffect } from 'react';

function useFriendStatus(friendID) {
  const [isOnline, setIsOnline] = useState(null);

  useEffect(() => {
    function handleStatusChange(status) {
      setIsOnline(status.isOnline);
    }

    ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange);
    return () => {
      ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange);
    };
  });

  return isOnline;
}
</pre>
                </code>
                <p>
                    Здесь нет ничего нового, логика просто скопирована из компонентов выше. Так же как и в компонентах,
                    убедитесь, что вы не используете другие хуки внутри условных операторов и вызываете их на верхнем
                    уровне вашего хука.
                </p>
                <p>
                    В отличие от React-компонента, пользовательский хук не обязательно должен иметь конкретную
                    сигнатуру. Мы можем решить, что он принимает в качестве аргументов, и должен ли он что-либо
                    возвращать. Другими словами, всё как в обычных функциях. Её имя всегда следует начинать с use, чтобы
                    вы могли сразу увидеть, что к ней применяются правила хуков.
                </p>
                <p>
                    Цель нашего хука useFriendStatus — подписать нас на статус друга. Поэтому он принимает в качестве
                    аргумента friendID и возвращает статус друга в сети:
                </p>
                <code>
<pre>
function useFriendStatus(friendID) {
  const [isOnline, setIsOnline] = useState(null);

  // ...

  return isOnline;
}
</pre>
                </code>
                <h2>Использование пользовательского хука</h2>
                <p>
                    Вначале нашей целью было удалить дублированную логику из компонентов FriendStatus и FriendListItem.
                    Они оба хотят знать, есть ли друг в сети.
                </p>
                <p>
                    Теперь, когда мы извлекли эту логику в хук useFriendStatus, мы можем его использовать:
                </p>
                <code>
<pre>
function FriendStatus(props) {
  const isOnline = useFriendStatus(props.friend.id);

  if (isOnline === null) {
    return 'Загрузка...';
  }
  return isOnline ? 'В сети' : 'Не в сети';
}
</pre>
                </code>
                <code>
<pre>
function FriendListItem(props) {
  const isOnline = useFriendStatus(props.friend.id);

  return (
    &lt;li style={{ color: isOnline ? 'green' : 'black' }}&gt;
      {props.friend.name}
    &lt;/li&gt;
  );
}
</pre>
                </code>
                <p>
                    <strong>Код будет работать как раньше?</strong> Да, он работает точно так же. Если вы посмотрите
                    внимательно, вы
                    заметите, что мы не вносили никаких изменений в логику. Всё, что мы сделали, это извлекли общий код
                    в отдельную функцию. <strong>Пользовательские хуки — это скорее соглашение, соответствующее дизайну
                        хуков,
                        нежели чем возможность самого React.</strong>
                </p>
                <p>
                    <strong>Должен ли я писать «use» в начале названия хука?</strong> Очень желательно. Это важное
                    условие, без которого
                    мы не сможем автоматически проверять нарушения правил хуков, потому что не определим, содержит ли
                    определённая функция вызовы хуков внутри.
                </p>
                <p>
                    <strong>У хука, используемого в двух компонентах, одинаковое состояние?</strong> Нет.
                    Пользовательские хуки — это
                    механизм повторного использования логики с состоянием (например, установка подписки и сохранение
                    текущего значения), но каждый раз, когда вы используете пользовательский хук, всё состояние и
                    эффекты внутри него полностью изолированы.
                </p>
                <p>
                    <strong>Как пользовательский хук получает изолированное состояние?</strong> Каждый вызов хука
                    получает изолированное
                    состояние. Поскольку мы вызываем useFriendStatus напрямую, с точки зрения React наш компонент просто
                    вызывает useState и useEffect. И как мы узнали ранее, мы можем вызывать useState и useEffect много
                    раз в одном компоненте, и они будут полностью независимы.
                </p>
                <h3>Совет: Передача информации между хуками</h3>
                <p>
                    Поскольку хуки являются функциями, мы можем передавать информацию между ними.
                </p>
                <p>
                    Продемонстрируем это, используя другой компонент из нашего гипотетического примера чата. Это
                    средство выбора получателей сообщений чата, которое показывает, находится ли выбранный в данный
                    момент друг в сети:
                </p>
                <code>
<pre>
const friendList = [
  { id: 1, name: 'Татьяна' },
  { id: 2, name: 'Алла' },
  { id: 3, name: 'Лиля' },
];

function ChatRecipientPicker() {
  const [recipientID, setRecipientID] = useState(1);
  const isRecipientOnline = useFriendStatus(recipientID);

  return (
    &lt;&gt;
      &lt;Circle color={isRecipientOnline ? 'green' : 'red'} /&gt;
      &lt;select
        value={recipientID}
        onChange={e => setRecipientID(Number(e.target.value))}
      &gt;
        {friendList.map(friend => (
          &lt;option key={friend.id} value={friend.id}&gt;
            {friend.name}
          &lt;/option&gt;
        ))}
      &lt;/select&gt;
    &lt;/&gt;
  );
}
</pre>
                </code>
                <p>
                    Мы сохраняем выбранный в настоящее время идентификатор друга в переменной состояния recipientID и
                    обновляем его, если пользователь выбирает другого друга в <code>&lt;select&gt;</code>.
                </p>
                <p>
                    Поскольку вызов хука useState даёт нам последнее значение переменной состояния recipientID, мы можем
                    передать его в наш пользовательский хук useFriendStatus в качестве аргумента:
                </p>
                <code>
<pre>
const [recipientID, setRecipientID] = useState(1);
const isRecipientOnline = useFriendStatus(recipientID);
</pre>
                </code>
                <p>
                    Это позволяет нам узнать, находится ли выбранный друг в сети. Если мы выберем другого друга и
                    обновим переменную состояния recipientID, наш хук useFriendStatus отменит подписку на ранее
                    выбранного друга и подпишется на статус вновь выбранного.
                </p>
            </section>
            <section class="main-section" id="manual">
                <header id="Справочник_API_хуков">
                    <h1>Справочник API хуков</h1>
                </header>
                <p>
                    На этой странице описан API, относящийся к встроенным хукам React.
                </p>
                <ul>
                    <li>
                        <p>Основные хуки</p>
                        <ul>
                            <li>useState</li>
                            <li>useEffect</li>
                            <li>useContext</li>
                        </ul>
                    </li>
                    <li>
                        <p>Дополнительные хуки</p>
                        <ul>
                            <li>useReducer</li>
                            <li>useCallback</li>
                            <li>useMemo</li>
                        </ul>
                    </li>
                </ul>
                <hr>
                <h2>Основные хуки</h2>
                <h3>useState</h3>
                <code>
<pre>
const [state, setState] = useState(initialState);
</pre>
                </code>
                <p>
                    Возвращает значение с состоянием и функцию для его обновления.
                </p>
                <p>
                    Во время первоначального рендеринга возвращаемое состояние (state) совпадает со значением,
                    переданным в качестве первого аргумента (initialState).
                </p>
                <p>
                    Функция setState используется для обновления состояния. Она принимает новое значение состояния и
                    ставит в очередь повторный рендер компонента.
                </p>
                <code>
<pre>
setState(newState);
</pre>
                </code>
                <p>
                    Во время последующих повторных рендеров первое значение, возвращаемое useState, всегда будет самым
                    последним состоянием после применения обновлений.
                </p>
                <p>
                    Если новое состояние вычисляется с использованием предыдущего состояния, вы можете передать функцию
                    в setState. Функция получит предыдущее значение и вернёт обновлённое значение. Вот пример компонента
                    счётчик, который использует обе формы setState:
                </p>
                <code>
<pre>
function Counter({initialCount}) {
  const [count, setCount] = useState(initialCount);
  return (
    &lt;&gt;
      Счёт: {count}
      &lt;button onClick={() => setCount(initialCount)}&gt;Сбросить&lt;/button&gt;
      &lt;button onClick={() => setCount(prevCount => prevCount - 1)}&gt;-&lt;/button&gt;
      &lt;button onClick={() => setCount(prevCount => prevCount + 1)}&gt;+&lt;/button&gt;
    &lt;/&gt;
  );
}
</pre>
                </code>
                <p>
                    Кнопки «+» и «-» используют функциональную форму, потому что обновлённое значение основано на
                    предыдущем значении. Но кнопка «Сбросить» использует обычную форму, потому что она всегда
                    устанавливает счётчик обратно в 0.
                </p>
                <p>
                    Если функция обновления возвращает абсолютно такой же результат как и текущее состояние, то
                    последующие повторные рендеры будут полностью пропущены.
                </p>
                <p>
                    Аргумент initialState — это состояние, используемое во время начального рендеринга. В последующих
                    рендерах это не учитывается. Если начальное состояние является результатом дорогостоящих вычислений,
                    вы можете вместо этого предоставить функцию, которая будет выполняться только при начальном
                    рендеринге:
                </p>
                <code>
<pre>
const [state, setState] = useState(() => {
  const initialState = someExpensiveComputation(props);
  return initialState;
});
</pre>
                </code>
                <p>
                    Если вы обновите состояние хука тем же значением, что и текущее состояние, React досрочно выйдет из
                    хука без повторного рендера дочерних элементов и запуска эффектов.
                </p>
                <p>
                    Обратите внимание, что для React всё ещё может быть необходим повторный рендер этого компонента. Это
                    не должно быть проблемой, потому что React не будет сильно «углубляться» в дерево. Если вы делаете
                    дорогостоящие вычисления во время рендеринга, вы можете оптимизировать их с помощью useMemo.
                </p>
                <h3>useEffect</h3>
                <code>
<pre>
useEffect(didUpdate);
</pre>
                </code>
                <p>
                    Принимает функцию, которая содержит императивный код, возможно, с эффектами.
                </p>
                <p>
                    Мутации, подписки, таймеры, логирование и другие побочные эффекты не допускаются внутри основного
                    тела функционального компонента (называемого этапом рендеринга React). Это приведёт к запутанным
                    ошибкам и несоответствиям в пользовательском интерфейсе.
                </p>
                <p>
                    Вместо этого используйте useEffect. Функция, переданная в useEffect, будет запущена после того, как
                    рендер будет зафиксирован на экране. Думайте об эффектах как о лазейке из чисто функционального мира
                    React в мир императивов.
                </p>
                <p>
                    По умолчанию эффекты запускаются после каждого завершённого рендеринга, но вы можете решить
                    запускать их только при изменении определённых значений.
                </p>
                <p>Очистка эффекта</p>
                <p>
                    Часто эффекты создают ресурсы, которые необходимо очистить (или сбросить) перед тем, как компонент
                    покидает экран, например подписку или идентификатор таймера. Чтобы сделать это, функция переданная в
                    useEffect, может вернуть функцию очистки. Например, чтобы создать подписку:
                </p>
                <code>
<pre>
useEffect(() => {
  const subscription = props.source.subscribe();
  return () => {
    // Очистить подписку
    subscription.unsubscribe();
  };
});
</pre>
                </code>
                <p>
                    Функция очистки запускается до удаления компонента из пользовательского интерфейса, чтобы
                    предотвратить утечки памяти. Кроме того, если компонент рендерится несколько раз (как обычно
                    происходит), <strong>предыдущий эффект очищается перед выполнением следующего эффекта.</strong> В
                    нашем примере это
                    означает, что новая подписка создаётся при каждом обновлении. Чтобы избежать воздействия на каждое
                    обновление, обратитесь к следующему разделу.
                </p>
                <p>
                    Порядок срабатывания эффектов
                </p>
                <p>
                    В отличие от componentDidMount и componentDidUpdate, функция, переданная в useEffect, запускается во
                    время отложенного события после разметки и отрисовки. Это делает хук подходящим для многих
                    распространённых побочных эффектов, таких как настройка подписок и обработчиков событий, потому что
                    большинство типов работы не должны блокировать обновление экрана браузером.
                </p>
                <p>
                    Однако не все эффекты могут быть отложены. Например, изменение DOM, которое видно пользователю,
                    должно запускаться синхронно до следующей отрисовки, чтобы пользователь не замечал визуального
                    несоответствия. (Различие концептуально схоже с пассивным и активным слушателями событий.) Для этих
                    типов эффектов React предоставляет один дополнительный хук, называемый useLayoutEffect. Он имеет ту
                    же сигнатуру, что и useEffect, и отличается только в его запуске.
                </p>
                <p>
                    Хотя useEffect откладывается до тех пор, пока браузер не выполнит отрисовку, он гарантированно
                    срабатывает перед любыми новыми рендерами. React всегда полностью применяет эффекты предыдущего
                    рендера перед началом нового обновления.
                </p>
                <p>Условное срабатывание эффекта</p>
                <p>
                    По умолчанию эффекты запускаются после каждого завершённого рендера. Таким образом, эффект всегда
                    пересоздаётся, если значение какой-то из зависимости изменилось.
                </p>
                <p>
                    Однако в некоторых случаях это может быть излишним, например, в примере подписки из предыдущего
                    раздела. Нам не нужно создавать новую подписку на каждое обновление, а только если изменился проп
                    source.
                </p>
                <p>
                    Чтобы реализовать это, передайте второй аргумент в useEffect, который является массивом значений, от
                    которых зависит эффект. Наш обновлённый пример теперь выглядит так:
                </p>
                <code>
<pre>
useEffect(
  () => {
    const subscription = props.source.subscribe();
    return () => {
      subscription.unsubscribe();
    };
  },
  [props.source],
);
</pre>
                </code>
                <p>
                    Теперь подписка будет создана повторно только при изменении props.source.
                </p>
                <p>
                    Если вы хотите использовать эту оптимизацию, обратите внимание на то, чтобы массив включал в себя
                    все значения из области видимости компонента (такие как пропсы и состояние), которые могут
                    изменяться с течением времени, и которые будут использоваться эффектом. В противном случае, ваш код
                    будет ссылаться на устаревшее значение из предыдущих рендеров. Отдельные страницы документации
                    рассказывают о том, как поступить с функциями и что делать с часто изменяющимися массивами.
                </p>
                <p>
                    Если вы хотите запустить эффект и сбросить его только один раз (при монтировании и размонтировании),
                    вы можете передать пустой массив ([]) вторым аргументом. React посчитает, что ваш эффект не зависит
                    от каких-либо значений из пропсов или состояния и поэтому не будет выполнять повторных запусков
                    эффекта. Это не обрабатывается как особый случай — он напрямую следует из логики работы входных
                    массивов.
                </p>
                <p>
                    Если вы передадите пустой массив ([]), пропсы и состояние внутри эффекта всегда будут иметь
                    значения, присвоенные им изначально. Хотя передача [] ближе по модели мышления к знакомым
                    componentDidMount и componentWillUnmount, обычно есть более хорошие способы избежать частых
                    повторных рендеров. Не забывайте, что React откладывает выполнение useEffect, пока браузер не
                    отрисует все изменения, поэтому выполнение дополнительной работы не является существенной проблемой.
                </p>
                <p>
                    Массив зависимостей не передаётся в качестве аргументов функции эффекта. Тем не менее, в теории вот
                    что происходит: каждое значение, на которое ссылается функция эффекта, должно также появиться в
                    массиве зависимостей. В будущем достаточно продвинутый компилятор сможет создать этот массив
                    автоматически.
                </p>
                <h2>useContext</h2>
                <code>
<pre>
const value = useContext(MyContext);
</pre>
                </code>
                <p>
                    Принимает объект контекста (значение, возвращённое из React.createContext) и возвращает текущее
                    значение контекста для этого контекста. Текущее значение контекста определяется пропом value
                    ближайшего <code>&lt;MyContext.Provider&gt;</code> над вызывающим компонентом в дереве.
                </p>
                <p>
                    Когда ближайший <code>&lt;MyContext.Provider&gt;</code> над компонентом обновляется, этот хук
                    вызовет повторный рендер
                    с последним значением контекста, переданным этому провайдеру MyContext. Даже если родительский
                    компонент использует React.memo или реализует shouldComponentUpdate, то повторный рендер будет
                    выполняться, начиная c компонента, использующего useContext.
                </p>
                <p>
                    Запомните, аргумент для useContext должен быть непосредственно сам объект контекста:
                </p>
                <ul>
                    <li><strong>Правильно:</strong> useContext(MyContext)</li>
                    <li><strong>Неправильно:</strong> useContext(MyContext.Consumer)</li>
                    <li><strong>Неправильно:</strong> useContext(MyContext.Provider)</li>
                </ul>
                <p>
                    Компонент, вызывающий useContext, всегда будет перерендериваться при изменении значения контекста.
                    Если повторный рендер компонента затратен, вы можете оптимизировать его с помощью мемоизации.
                </p>
                <p>
                    Если вы были знакомы с API контекстов до появления хуков, то вызов useContext(MyContext) аналогичен
                    выражению <code>static contextType = MyContext</code> в классе, либо компоненту
                    <code>&lt;MyContext.Consumer&gt;</code>.
                </p>
                <p>
                    useContext(MyContext) позволяет только читать контекст и подписываться на его изменения. Вам всё ещё
                    нужен <code>&lt;MyContext.Provider&gt;</code> выше в дереве, чтобы предоставить значение для этого
                    контекста.
                </p>
                <p>
                    Соединим все вместе с Context.Provider
                </p>
                <code>
<pre>
const themes = {
  light: {
    foreground: "#000000",
    background: "#eeeeee"
  },
  dark: {
    foreground: "#ffffff",
    background: "#222222"
  }
};

const ThemeContext = React.createContext(themes.light);

function App() {
  return (
    &lt;ThemeContext.Provider value={themes.dark}&gt;
      &lt;Toolbar /&gt;
    &lt;/ThemeContext.Provider&gt;
  );
}

function Toolbar(props) {
  return (
    &lt;div&gt;
      &lt;ThemedButton /&gt;
    &lt;/div&gt;
  );
}

function ThemedButton() {
  const theme = useContext(ThemeContext);
  return (
    &lt;button style={{ background: theme.background, color: theme.foreground }}&gt;
      Я стилизован темой из контекста!
    &lt;/button&gt;
  );
}
</pre>
                </code>
                <h2>Дополнительные хуки</h2>
                <h3>useReducer</h3>
                <code>
<pre>
const [state, dispatch] = useReducer(reducer, initialArg, init);
</pre>
                </code>
                <p>
                    Альтернатива для useState. Принимает редюсер типа <code>(state, action) => newState</code>( и
                    возвращает текущее
                    состояние в паре с методом <code>dispatch</code>. (Если вы знакомы с Redux, вы уже знаете, как это
                    работает.)
                </p>
                <p>
                    Хук <code>useReducer</code> обычно предпочтительнее <code>useState</code>, когда у вас сложная
                    логика состояния, которая
                    включает в себя несколько значений, или когда следующее состояние зависит от предыдущего.
                    <code>useReducer</code>
                    также позволяет оптимизировать производительность компонентов, которые запускают глубокие
                    обновления, поскольку вы можете передавать <code>dispatch</code> вместо колбэков.
                </p>
                <p>
                    Вот пример счётчика из раздела <code>useState</code>, переписанный для использования редюсера:
                </p>
                <code>
<pre>
const initialState = {count: 0};

function reducer(state, action) {
  switch (action.type) {
    case 'increment':
      return {count: state.count + 1};
    case 'decrement':
      return {count: state.count - 1};
    default:
      throw new Error();
  }
}

function Counter() {
  const [state, dispatch] = useReducer(reducer, initialState);
  return (
    &lt;&gt;
      Count: {state.count}
      &lt;button onClick={() => dispatch({type: 'decrement'})}&gt;-&lt;/button&gt;
      &lt;button onClick={() => dispatch({type: 'increment'})}&gt;+&lt;/button&gt;
    &lt;/&gt;
  );
}
</pre>
                </code>
                <p>
                    React гарантирует, что идентичность функции dispatch стабильна и не изменяется при повторных
                    рендерах. Поэтому её можно безопасно не включать в списки зависимостей хуков useEffect и
                    useCallback.
                </p>
                <p>
                    Указание начального состояния
                </p>
                <p>
                    Существует два разных способа инициализации состояния useReducer. Вы можете выбрать любой из них в
                    зависимости от ситуации. Самый простой способ — передать начальное состояние в качестве второго
                    аргумента:
                </p>
                <code>
<pre>
const [state, dispatch] = useReducer(
    reducer,
    {count: initialCount}
  );
</pre>
                </code>
                <p>
                    Ленивая инициализация
                </p>
                <p>
                    Вы также можете создать начальное состояние лениво. Для этого вы можете передать функцию
                    <code>init</code> в
                    качестве третьего аргумента. Начальное состояние будет установлено равным результату вызова
                    <code>init(initialArg)</code>.
                </p>
                <p>
                    Это позволяет извлечь логику для расчёта начального состояния за пределы редюсера. Это также удобно
                    для сброса состояния позже в ответ на действие:
                </p>
                <code>
<pre>
function init(initialCount) {
  return {count: initialCount};
}

function reducer(state, action) {
  switch (action.type) {
    case 'increment':
      return {count: state.count + 1};
    case 'decrement':
      return {count: state.count - 1};
    case 'reset':
      return init(action.payload);
    default:
      throw new Error();
  }
}

function Counter({initialCount}) {
  const [state, dispatch] = useReducer(reducer, initialCount, init);
  return (
    &lt;&gt;
      Count: {state.count}
      &lt;button
        onClick={() => dispatch({type: 'reset', payload: initialCount})}&gt;
        Reset
      &lt;/button&gt;
      &lt;button onClick={() => dispatch({type: 'decrement'})}&gt;-&lt;/button&gt;
      &lt;button onClick={() => dispatch({type: 'increment'})}&gt;+&lt;/button&gt;
    &lt;/&gt;
  );
}

</pre>
                </code>
                <p>
                    Досрочное прекращение dispatch
                </p>
                <p>
                    сли вы вернёте то же значение из редюсера хука, что и текущее состояние, React выйдет без
                    перерисовки дочерних элементов или запуска эффектов.
                </p>
                <p>
                    Обратите внимание, что для React всё ещё может быть необходим повторный рендер этого компонента. Это
                    не должно быть проблемой, потому что React не будет сильно «углубляться» в дерево. Если вы делаете
                    дорогостоящие вычисления во время рендеринга, вы можете оптимизировать их с помощью useMemo.
                </p>
                <h3>useCallback</h3>
                <code>
<pre>
const memoizedCallback = useCallback(
  () => {
    doSomething(a, b);
  },
  [a, b],
);
</pre>
                </code>
                <p>
                    Возвращает мемоизированный колбэк.
                </p>
                <p>
                    Передайте встроенный колбэк и массив зависимостей. Хук <code>useCallback</code> вернёт
                    мемоизированную версию
                    колбэка, который изменяется только, если изменяются значения одной из зависимостей. Это полезно при
                    передаче колбэков оптимизированным дочерним компонентам, которые полагаются на равенство ссылок для
                    предотвращения ненужных рендеров (например, <code>shouldComponentUpdate</code>).
                </p>
                <p>
                    <code>useCallback(fn, deps)</code> — это эквивалент <code>useMemo(() => fn, deps)</code>
                </p>
                <p>
                    Массив зависимостей не передаётся в качестве аргументов для колбэка. Концептуально, однако, это то,
                    что они представляют: каждое значение, использованное в колбэке, должно также появиться в массиве
                    зависимостей. В будущем достаточно продвинутый компилятор может создать этот массив автоматически.
                </p>
                <h3>useMemo</h3>
                <code>
<pre>
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
</pre>
                </code>
                <p>
                    Возвращает мемоизированное значение.
                </p>
                <p>
                    Передайте «создающую» функцию и массив зависимостей. <code>useMemo</code> будет повторно вычислять
                    мемоизированное значение только тогда, когда значение какой-либо из зависимостей изменилось. Эта
                    оптимизация помогает избежать дорогостоящих вычислений при каждом рендере.
                </p>
                <p>
                    Помните, что функция, переданная <code>useMemo</code>, запускается во время рендеринга. Не делайте
                    там ничего,
                    что вы обычно не делаете во время рендеринга. Например, побочные эффекты принадлежат
                    <code>useEffect</code>, а не
                    <code>useMemo</code>.
                </p>
                <p>
                    Если массив не был передан, новое значение будет вычисляться при каждом рендере.
                </p>
                <p>
                    <strong>Вы можете использовать <code>useMemo</code> как оптимизацию производительности, а не как
                        семантическую гарантию.</strong>
                    В будущем React может решить «забыть» некоторые ранее мемоизированные значения и пересчитать их при
                    следующем рендере, например, чтобы освободить память для компонентов вне области видимости экрана.
                    Напишите свой код, чтобы он по-прежнему работал без <code>useMemo</code>, а затем добавьте его для
                    оптимизации
                    производительности.
                </p>
                <p>
                    Массив зависимостей не передаётся в качестве аргументов функции. Концептуально, однако, это то, что
                    они представляют: каждое значение, на которое ссылается функция, должно также появиться в массиве
                    зависимостей. В будущем достаточно продвинутый компилятор может создать этот массив автоматически.
                </p>
            </section>
        </main>
    </div>
</body>

</html>